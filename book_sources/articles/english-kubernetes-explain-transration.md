Kubernetes explain transration

```text
大家好， 我的名字是 Sai Vennam
我是 IBM 的开发人员倡导者
今天我带着另外一个视频回来了
我将在这里讨论所有关于 kubernetes 的事情
kuernetes 作为一个编排工具
允许你允许和管理你的基于容器的工作负载
今天我想对管理 kubernetes 服务的参考架构做一个高层次的分析
并深入了解你将如何进行微服务的部署
让我们从这里开始
因此我们这里已经勾勒出拼图的两面
在这里的左边，我们已经得到了云端
而我们这里得到是一个非常重要的组成部分
那将是 kubernetes master
kubernetes master 里面有很多重要的组件
但是今天我们要讨论的最重要的部分将是 kubernetes API
在主服务器上运行 kubernetes API 服务是运行所有工作负载不可缺少的一部分，并提供一系列的功能
允许我们准确地定义我们想如何运行我们的工作负载
在这里的右边，在客户管理的一边
我们有我们的工作节点
都是基于 kubernetes 的
我想指出有一个主要组件在我们每个 kubernetes 工作节点上运行的
这将是 kubectl
从本质上将， kubectl 负载调度和确保应用程序在我们的工作节点内健康运行
你可以想象 master 和 kubectl 会经常一起运行
让我们退后一步
为什么有人开始使用 kubernetes
也许他们有一些微服务构成了云原生应用程序
我们都知道，微服务都是通过网络相互通信的
为了真正简化这个例子
假设我们有一个前端和一个后端
这些是我们今天想要扩展和部署到该集群的两个组建
因此，kubenetes 使用 YAML 来定义发送给 API 服务的资源
最终创建实际的应用程序
因此，让我们从勾勒出一个简单的 YAML 来部署一个 pod 开始
pod 是一个非常小的逻辑单元，它允许你在工作节点上运行简单的容器
因此我们从这个开始
假设说我们有一个 pod,我们需要一个与之关联的镜像
假设它是一个容器
我们已经推送到 Docker hub
我们将使用我的注册表来处理这个
而且假设该应用程序的名称只是 f ，代表前端--版本1
还有一件事我想在这里添加
假设说我们有标签
标签非常重要
我们将在这里讨论为什么
因为它们运行我们准确定义我们这里得到的制品类型是什么
因此对于标签，我们就说应用是 f 代表前端
好的，所以我们就创建了这个
而我们要做的是通过我们的流程将它推送到一个工作节点
我们这里得到的是 kubectl
使用它，我们将能够部署我们所得到的简单清单，并且将它放在我们的一个工作节点中
因此，我们将通过 kubectl 推送清单
它击中了运行在 kubenetes master 上的 API
反过来，它将和其中一个 kubectls 对话
因为我们只是想部署其中的一个 pod 并启动它
所以看看
假设说，它在我们的第一个工作节点中启动了它，并贴上了我们给它的标签，应用程序是前台
这里要注意一件事：它实际上也得到了一个 IP
假设我们得到了一个以 .1 结尾的内部 ip 地址
因此，在这一点上，我们可以通过 ssh进入任何一个工作节点，并且使用该地址来命中该应用程序
因此，这对于部署一个简单的应用程序来说是非常好的
让我们更进一步
Kubernetes 有一个叫 deployments 的抽象
允许我们做一些事情并创造一些被称为期望状态的东西
因此，我们可以为 pod 定义我们想要的副本数量
如果 pod 发生了什么事情而死亡
它将为我们创建一个新的
因此，我们已经把 pod 标记为应用程序是前端
我们想说我们想创建，也许，三个副本
因此，回到我们这里的清单
我们需要做的一件事是告诉 kubernetes， 我们不想要一个 pod
我们想要一个 pod 的模版
所以，我们会划掉它
我们将为一个 pod 创建一个模版
在此基础上，我们还有一些其它想要的东西
所以， 副本的数量，将设我们想要三个
我们已经有了一个选择器
所以，我们要告诉这个 deployment 来管理任何以这种名称部署的应用程序
我们会在这里说鱼该选择器相匹配
同样，这也不是完全有效的 YAML
我只想让你了解一下 kubernetes 正在寻找工件的类型
我们在这里得到的最后一件事是
这是一个什么样的制品
这将是一个 deployment
好了，所以我们已经划掉了那个 pod ，我们这里已经有了一个新的清单
它将要做什么： 我们要通过 kubectl 推送它
它击中了 API 服务
现在它不是一种短暂的对象
Kubernetes 需要管理所需的状态
所以要做的是
只要我们有那个 deployment并且我们不删除它，它就会管理那个部署
它将在这里进行管理
因此，我们会说它创建了一个 deployment
而且由于我们有三个副本
它总是要确保我们有三个在运行
一旦我们创建了 deployment，我们就会发现
嘿，出事了，我们只有一个，我们还需要两个
因此，它要做什么
是它要安排部署该应用程序
凡是有资源的地方
我们仍然还有很多资源
大多数这些工作节点都是空的
所以它决定在每个不同的节点中放一个
所以，我们已经创建了 deployment
假设我们在这里为我们后端做同样的事情
因此，我们将创建另外一个应用程序的 deployment： 应用程序是后端
对于这个，让我们把它扩展两次
因此，我们将在这里，应该程序是后端
而且每个人都很开心
现在我们需要开始考虑关于这些服务之间的通信
我们讨论了每个 pod 都有一个 IP 地址
但我们也提到这些 pod 中的一些可能会死掉
也许你必须在某个时候更新它们
当一个 pod 离开并回来的时，它实际上有个不同的 IP 地址
因此，如果我们想从后台访问其中一个 pod 甚至用于外部使用
我们需要一个可以信赖的 IP 地址
而这是一个已经存在了一段时间的问题
而服务注册和服务发现公共的创建能解决这个问题
这是 kubernetes 内置的
因此，我们现在要做的是创建一个服务，以实际创建一个更稳定的 IP 地址
所以我们可以作为一个单一的应用程序来访问我们的 pod
而不是个别不同的服务
因此为了做到这一点，我们要在这里退一步
而我们将围绕这三个 pod 创建一个服务定义
要做到这一点我们需要一些清单 YAML
因此我们回到这里，在我们的文件中创建一个新的部分
这次我们有一个种类：service
而我们将需要一个选择器
同样，浙江省与我们这里的标签相匹配
而且我们在这里需要的最后一件事是一个类型
那么，我们要如何真正暴露这一点呢
但我们一会就回提到这一点
默认情况下，该类型将是 cluster IP
这意味着我们的服务可以从集群内部访问
所以，通过 kubectl 部署它
击中我们的 master， 在这里进行
并创建我们太刀的抽象
我们可以说我们也为后端创建了另外一个
因此，我们现在得到的是一个集群 IP
让我们简称为 CLIP
而这将是一个内部 IP
比如说，它以5结尾
然后另外一个集群 IP 用于我的在这里的其他服务
而我们会说以 .6 结尾
因此，现在我们有了一个 IP，我们可以用来在这些服务之间进行可靠的通讯
此外，KubeDNS 服务
通常默认运行
将这些服务更容易相互访问
他们可以只使用他们的名字
因此，他们可以使用前端这个名字来命中对方
后端 — 简称 F 或 B
所以，我们已经得到了这个，我们谈到了现在的服务可以相互交谈
通过使用这些集群 IP
因此，解决了集群内的通信
为此，我们需要做的是定义这个服务的类型
而我们想要的是一个负载均衡器
其实还有其他的暴露方式，比如节点端口也是如此
但一个负载均衡器，本质上它要做的是
这是实际 Kubernetes 工作节点的内部
我们可以创建一个外卖 IP
而这可能是，比方说，一个169的地址
而现在，我们可以做的是将其直接暴露给最终用户
这样他们就可以通过直接使用该服务访问该前端
我们今天在这里讨论了3个主要组件
我们已经得到了 pod
pod， 然后由deployment部署和管理
然后，促进这些 deployment 使用 service 创建pod 的访问
这些是与 kubernetes 主节点和所有工作节点一起工作的3个主要组件
允许你真正重新定义你的 DEVOPS 工作流程，将你的应用程序部署到受管理的 kubenetes 服务中
我知道我们今天谈了很多
但我们希望在未来轻装上阵视频中，能够进入很深入的主题
例如，类似 deployment 的东西
所以，请随时在下面发表评论
给我们留下任何反馈
一定要订阅
并继续关注未来更多的轻装上阵视频
并非常感谢你今天加入我

```





















